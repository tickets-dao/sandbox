#!/bin/sh

VERSION="2.1.1"
DATA="/data"
STATE="/state"
STATE_HASH="$STATE/.hash"
STATE_FILE="$STATE/.file"
STATE_FILE_TMP="/tmp/.file"
CONNECTION_TMP="/tmp/.connection.yaml"
CHANNEL_DATA="$DATA/channel"
CHANNEL_STATE="$STATE/channel"
CONNECTION_STATE="$STATE/connection"
CONNECTION_DATA="$DATA/out/connection"
OUT="/dev/shm/out"
[ -z "$ORDERER_PORT" ] && ORDERER_PORT="7050"
[ -z "$PEER_PORT" ] && PEER_PORT="7051"
CRYPTOMATERIAL="${STATE}/peerOrganizations ${STATE}/ordererOrganizations"
CHAINCODE_TMP="/tmp/chaincode.tar.gz"
CUSTOM_CHECK_FILE=".custom_check"
ENV="/state/.env"
[ -z "$SLEEP_STATE" ] && SLEEP_STATE="30"
[ -z "$SLEEP_ERROR" ] && SLEEP_ERROR="30"

_err() { # print [message] and exit with error
    echo "-- ERROR: 'sandbox:$VERSION' $1"
    exit 1
}

_info() { # print [message]
    echo "-- INFO: $1"
}

_info_and_exit() { # print [message] and exit
    _info "$1"
    exit
}

_setup_extra_packages() { # setup exta package that not included in base image
    which "openssl" 2>&1 >/dev/null || \
        apk add --no-cache openssl=~1 || \
        _err "failed to install openssl"

    if ! which "base58" 2>&1 >/dev/null 
    then
        apk add --no-cache py3-pip=~20
        pip3 install base58==2.* || _err "failed to install base58"
    fi
}

_equal() { # compare if [file1] is equal [file2]
    [ -r "$1" -o -r "$2" ] || return 1
    [ "$(cat "$1" | md5sum)" = "$(cat "$2" | md5sum)" ]
}

_copy() { # copy [file] to [path]
    cp -fv "$1" "$2"
}

_configtx_orderer_fqdn_port() { # shows orderer:port fqdns and limit [999] output hosts
    local limit
    [ -z "$2" ] && limit="999" || limit="$2"
    sed -n '/^Orderer:/,/Organizations:/p' "$1" | awk '/- [a-z]+-/ {print $2}' | head -n "$limit"
}

_configtx_orderer_fqdn() { # shows orderer fqdns and limit [999] output hosts
    local limit
    [ -z "$2" ] && limit="999" || limit="$2"
    _configtx_orderer_fqdn_port "$1" | cut -d ':' -f 1 | head -n "$limit"
}

_configtx_peer_fqdn() { # shows orderer fqdns and limit [999] output hosts
    local limit
    [ -z "$2" ] && limit="999" || limit="$2"
    grep -E "^# peer " "$1" | cut -d " " -f 3 | head -n "$limit"
}

_org_by_hostname() { # return organisation by [hostname] 
    echo "${1#*.}"
}

_org_by_configtx() { # shows organisations by [configtx.yaml] and limit [999] output lines
    local limit
    [ -z "$2" ] && limit="999" || limit="$2"
    grep -E '\sID: '  "$1" | awk '{print $2}' | head -n "$limit"
}

_crypto_basedir_by_hostname() { # return path to directory with cryptomaterials by [hostname]
    find $CRYPTOMATERIAL -type d -name "$1" 2>/dev/null \
        | head -n 1
}

_crypto_ca_by_hostname() { # returns path to ca certificate by [hostname]
    echo "$STATE/$1/tls/ca.crt"
}

_crypto_admin_cert_by_org() { # return path to Admin certificate by [org]
    find $CRYPTOMATERIAL -type d -name "$1" -print0 2>/dev/null | \
        xargs -0rI X readlink -f "X/users/Admin@$1/tls/client.crt"
}

_crypto_admin_key_by_org() { # return path to Admin key by [org]
    find $CRYPTOMATERIAL -type d -name "$1" -print0 2>/dev/null | \
        xargs -0rI X readlink -f "X/users/Admin@$1/tls/client.key"
}

_crypto_admin_ca_by_org() { # return path to Admin ca certificat  by [org]
    find $CRYPTOMATERIAL -type d -name "$1" -print0 2>/dev/null | \
        xargs -0rI X readlink -f "X/users/Admin@$1/tls/ca.crt"
}

_crypto_admin_msp_by_org() { # return path to msp directory for Admin user by [org]
    find $CRYPTOMATERIAL -type d -name "$1" -print0 2>/dev/null | \
        xargs -0rI X readlink -f "X/users/Admin@$1/msp"
}

_crypto_msp_by_org() { # return path to msp directory by [org] and [user]
    find $CRYPTOMATERIAL -type d -name "$1" -print0 2>/dev/null | \
        xargs -0rI X readlink -f "X/users/$2@$1/msp"
}

_expose_by_hostname() { # return ports that exposed from compose file by [hostname]
    local search
    search="${1//[.-]/_}"
    search="${search#test_}"
    search="EXP_${search^^}"
    grep -m 1 "^$search" "$ENV" | cut -d "=" -f 2 | cut -d ":" -f 1
}

_tool_der_public_by_private() { # generate der public data by [private_key_pem_file]
    openssl ec -in "$1" -pubout | openssl ec -pubin -outform DER
}

_tool_ibs() { # return asn1 data offset by [private_key_pem_file]
    # magic bit offset for ec keys
    openssl ec -check -in "$1" &>/dev/null && echo "26" || false
}

_tool_wallet() { # generate wallet (base58check->sha256->pubkey) by [private_key_pem_file]
    ibs="$(_tool_ibs "$1")" || _err "failed to get offset"
    _tool_der_public_by_private "$1" | \
        dd ibs="$ibs" skip=1 | \
        openssl dgst -sha256 -binary | \
        base58 -c
    echo
} 2> /dev/null

_tool_ski() { # generate SKI by [private_key_pem_file]
    ibs="$(_tool_ibs "$1")" || _err "failed to get offset"
    _tool_der_public_by_private "$1" | \
        dd ibs="$ibs" skip=1 | \
        openssl dgst -sha256 | \
        cut -d ' ' -f2
} 2> /dev/null

_robot_state_dirs() { # shows robot service state directory
    find "$STATE" -type d -name "test-robot*" -mindepth 1 -maxdepth 1
}

_observer_state_dirs() { # shows observer services state directories
    find "$STATE" -type d -name "test-observer*" -mindepth 1 -maxdepth 1
}

_info "$0"
cd "$WORK" || _err "failed to set work directory"
